import { Backend, BackendTrack, BackendTrackState } from './backend'
import { lexify } from './compiler/lexer'
import { generateModule } from './compiler/moduleCodeGen'
import { parse as compilerParse } from './compiler/parser'
import { envTypes } from './env-types'
import { Frontend } from './frontend'

export namespace Jit {
  export const Apis = new Set([
    'engine_get_clock',
    'engine_get_rateSamples',
    'fade_fadeIn',
    'fade_fadeOut',
    'join_join21',
    'copy_copyMem',
    'copy_copyInto',
  ])

  export interface Meta {
    engine: number
    outs: number[]
    tracks: BackendTrack[]
    envTypes: Record<string, string>
  }

  export interface Module {
    run(begin: number, end: number): void
    start(begin: number, end: number): void
    stop(begin: number, end: number): void
    reset(begin: number, end: number): void
    update(begin: number, end: number): void
  }

  export interface Instance {
    exports: Module
  }
}

export function jit(meta: Jit.Meta) {
  // console.log(meta)

  const code: string[] = []

  code.push(...Object.entries(meta.envTypes).map(([id, type]) =>
    `import ${id}: fn ${type} from "env/${id}"`
  ))

  code.push(`
    engine: i32 = ${meta.engine}
    main_out_0: i32 = ${meta.outs[0]}
    main_out_1: i32 = ${meta.outs[1]}
    out_0: i32 = 0
    out_1: i32 = 0
    clock: i32
    time: f64

    main: fn () void {
      clock = engine_get_clock(engine)
    }
  `)

  function makeMethod(
    name: string,
    minState: BackendTrackState,
    bodyFn: (y: number, t: BackendTrack) => void,
    channelFn?: (x: number, y: number, t: BackendTrack) => void
  ) {
    code.push(`
      export ${name}
      ${name}: fn (begin: i32, end: i32) void {
        time = engine_Clock_get_time(clock)
    `)

    let count = 0

    for (const [y, t] of meta.tracks.entries()) {
      if (t.state < minState) continue
      if (count > 0) {
        code.push(`engine_Clock_set_time(clock, time)`)
      }
      bodyFn(y, t)
      writeOuts(count, y, t, channelFn)
      count++
    }

    if (!count) {
      code.push(`engine_Clock_set_time(clock, time + ( ((to_f64 end) - (to_f64 begin)) / (to_f64 engine_get_rateSamples(engine)) ))`)
    }

    code.push('}')
  }

  function copyMems(mems: [Float32Array, Float32Array][]) {
    for (const [a, b] of mems) {
      code.push(`copy_copyMem(${a.byteOffset},${b.byteOffset},${a.length << 2})`)
    }
  }

  function writeOuts(count: number, y: number, t: BackendTrack, channelFn?: (x: number, y: number, t: BackendTrack) => void) {
    for (const x of [0, 1]) {
      code.push(`out_${x} = ${t[t.active]!.payload.outs[x].byteOffset}`)
      channelFn?.(x, y, t)
      if (count > 0) {
        code.push(`join_join21(begin, end, main_out_${x}, out_${x}, main_out_${x})`)
      }
      else {
        code.push(`copy_copyInto(begin, end, out_${x}, main_out_${x})`)
      }
    }
  }

  function run(y: number, t: BackendTrack) {
    code.push(`${t.active}${y}_run(begin, end)`)
  }

  makeMethod('run', BackendTrackState.FadeIn, run)

  makeMethod('start', BackendTrackState.FadeIn, run, x => {
    code.push(`fade_fadeIn(32, begin, end, out_${x})`)
  })

  makeMethod('stop', BackendTrackState.FadeIn, run, x => {
    code.push(`fade_fadeOut(128, begin, end, out_${x})`)
  })

  makeMethod('reset', BackendTrackState.FadeIn, run, (x, y, t) => {
    code.push(`fade_fadeOut(128, begin, end, out_${x})`)
    copyMems(t[t.active]!.payload.memsReset)
    code.push(`${t.active}${y}_reset()`)
  })

  makeMethod('update', BackendTrackState.FadeOut, (y, t) => {
    if (t.active === 'next') {
      copyMems(t.next!.payload.mems)
      code.push(
        `ctrl${y}_run(begin, end)`
      )
      copyMems(t.next!.payload.memsAfter)
      code.push(`
        ctrl${y}_update_gens()
        next${y}_write_literals()
        next${y}_run(begin, end)
      `)
      for (const x of [0, 1]) {
        code.push(`fade_fadeIn(128, begin, end, ${t.next!.payload.outs[x].byteOffset})`)
        code.push(`fade_fadeOut(128, begin, end, ${t.ctrl!.payload.outs[x].byteOffset})`)
        code.push(`
          join_join21(
            begin, end,
            ${t.ctrl!.payload.outs[x].byteOffset},
            ${t.next!.payload.outs[x].byteOffset},
            ${t.next!.payload.outs[x].byteOffset}
          )
        `)
      }
    }
    else {
      if (t.state === BackendTrackState.FadeIn) {
        code.push(`ctrl${y}_write_literals()`)
      }
      code.push(`ctrl${y}_run(begin, end)`)
      if (t.state === BackendTrackState.FadeOut) {
        copyMems(t.ctrl!.payload.memsAfter)
        code.push(`ctrl${y}_update_gens()`)
        for (const x of [0, 1]) {
          code.push(`fade_fadeOut(128, begin, end, ${t.ctrl!.payload.outs[x].byteOffset})`)
        }
      }
      else if (t.state === BackendTrackState.FadeIn) {
        // for (const x of [0, 1]) {
        //   code.push(`fade_fadeIn(32, begin, end, ${t.ctrl!.payload.outs[x].byteOffset})`)
        // }
      }
    }
  })

  const text = code.join('\n')
  const tokens = lexify(text)
  const ast = compilerParse(tokens)
  const wasm = generateModule(ast)
  const binary = wasm.toByteArray()

  return { text, binary }
}

export async function compileJit(frontend: Frontend, backend: Backend) {
  frontend.debug && console.groupCollapsed('jit')

  const meta: Jit.Meta = {
    engine: frontend.engine,
    tracks: backend.tracks,
    outs: backend.mainOuts!.map((x) => x.ptr),
    envTypes: {
      ...Object.fromEntries(Object.entries(envTypes)
        .filter(([key]) =>
          Jit.Apis.has(key)
        )),
      ...Object.fromEntries(backend.tracks.flatMap(
        (track, y) => {
          frontend.debug && console.log('TRACK', y, BackendTrackState[track.state], track.active)
          const ctrl = track.ctrl
          const next = track.next
          return ctrl ? [
            [`ctrl${y}_run`, `(i32 i32) void`],
            [`ctrl${y}_update_gens`, `() void`],
            [`ctrl${y}_reset`, `() void`],
            [`ctrl${y}_write_literals`, `() void`],
            next && [`next${y}_run`, `(i32 i32) void`],
            next && [`next${y}_reset`, `() void`],
            next && [`next${y}_write_literals`, `() void`],
          ].filter(Boolean) : []
        }))
    }
  }

  const result = jit(meta)

  if (frontend.debug) {
    console.log(result.text)
    console.groupEnd()
  }

  return result.binary
}
