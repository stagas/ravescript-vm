import { AstNode, Token as Node, Token, parse, tokenize } from './lang'
import { NumberInfo, parseNumber } from './util'
import { envTypes } from './env-types'
import { envGens, envLookupMethod } from './env-info'
import { float } from './compiler'
import { GenRuntime } from './frontend'
import { randomId } from 'everyday-utils'

const audioLabels = ['in', 'sidechain']

const types: Record<string, ValueType[]> = {
  in: ['audio', 'scalar'],
  cut: ['literal', 'scalar', 'audio', 'list'],
  hz: ['literal', 'scalar', 'audio', 'list'],
  offset: ['literal', 'scalar', 'audio', 'list'],
}

const zero = parse([...tokenize(`[zero]`)])

export class Emitter {
  code: string[] = []
  updates: string[] = []
  lists: string[] = []

  emit(code: string) {
    this.code.push(code)
  }

  emitUpdate(code: string) {
    this.updates.push(code)
  }

  emitList(code: string) {
    this.lists.push(code)
  }
}

/** These are the types that can be pushed into the scope stack. */
export type ValueType =
  | 'id'
  | 'audio'
  | 'literal'
  | 'list'
  | 'scalar'
  | 'proc'
  | 'native'
  | 'special'
  | 'string'

export type VNodeType =
  | AstNodeType
  | ValueType

export type Value = (
  | VNode<'id'>
  | VNode<'native'>
  | VNode<'string'>
  | VNode<'special'>
  | VNode<'scoped'>
  | Caller
  | VAudio
  | VScalar
  | VLiteral
  | VProc
  | VList
)

export interface RuntimeInfo {
  code: string
  ptr: number
}

export interface VNode<T extends VNodeType = VNodeType> extends AstNode<T> {
  tokens: VNode<any>[]
  stack: VNode<T>[]
  owner?: VNode<T>
  parent?: VNode<T>[]
}

export interface Gen extends RuntimeInfo {
  kind: string
  callers: Caller[]
  locals: Record<string, string>
  tokens: VNode[]
  audio?: VAudio
  runtime?: GenRuntime
}

export interface Param {
  target: VLiteral
  op: VNode<'op'>
  name: VNode<'string'> | undefined
  mute: VNode<'special'> | undefined
  solo: VNode<'special'> | undefined
  min: number
  max: number
  step: number
  slope: number
  last: VAudio | undefined
  nodes: VNode[]
}

export interface Caller extends VNode<'scoped'> {
  ref: VNode<'scoped'>
  key: string
  audio?: VAudio
}

export interface VAudio extends VNode<'audio'>, RuntimeInfo {
  gen?: Gen
  callers: Caller[]
  floats?: Float32Array
}
export interface VScalar extends VNode<'scalar'>, RuntimeInfo { }
export interface VLiteral extends VNode<'literal'>, NumberInfo, RuntimeInfo { }

export interface VProc extends VNode<'proc'> {
  stack: AstNode<any>[]
}

export interface VList<T extends Value = Value> extends VNode<'list'> {
  items: T[]
}

function raise(message: string, v: VScope): asserts message is never {
  v = v.top
  throw new Error(message, { cause: { nodes: [...v.nodes].filter(v => !v.meta.hidden) } })
}

function raiseInvalidBinaryOp(op: AstNode<'op'>, lhs: Value, rhs: Value, v: VScope) {
  raise(`Invalid operation "${op.text}" for types: lhs=${lhs.type} rhs=${rhs.type}.`, v)
}

type GetSetU<T> = T extends Set<infer U> ? U : never

type GetMapUV<T> = T extends Map<infer U, infer V> ? [U, V] : never

const callerKeys = new WeakMap<AstNode<'scoped'>, string>()
// const tokenKeys = new WeakMap<CstNode<'op'>, string>()

function filter(stack: Value[], types: ValueType[] | undefined, useId = false) {
  const needId = useId && types?.length === 1 && types[0] === 'id'
  return !types
    ? stack
    : stack.filter((x) =>
      (needId && x.meta.local)
      || types.includes(x.type)
    )
}

export class VScope {
  top: VScope = this

  children: Set<VScope> = new Set()
  nodes: Set<AstNode> = new Set()

  used: Set<Value> = new Set()

  locals: Map<string, Value> = new Map()
  params: Map<VLiteral, Param> = new Map()
  labelReceiver?: VNode<'label'> | null
  placeholders: Map<string, Value> = new Map()

  stack: Value[] = []

  gens: Map<AstNode<'native'>, Gen> = new Map()

  audios: Set<VAudio> = new Set()
  literals: Map<AstNode<'number'>, VLiteral> = new Map()
  scalars: Set<VScalar> = new Set()
  listItems = 0

  constructor(public emitter: Emitter, public parent?: VScope, public boundary = false) {
    if (parent) {
      parent.children.add(this)
      this.top = parent.top
    }
  }

  lookup<T extends Value = Value>(name: string, deep = false): T | undefined {
    // console.log('SEARCH', name, deep)
    let level = 0
    let s: VScope | undefined = this
    let procsOnly = false
    let local: T | undefined

    do {
      level++

      // console.log(s, s.locals.has(name))
      if (s.locals.has(name)) {
        const value = s.locals.get(name)! as T

        if (!procsOnly || value.type === 'proc') {
          local = value
          if (level > 1 || s?.parent?.boundary) return local
        }
      }
      if (s.boundary && !deep) {
        procsOnly = true
      }
    } while (s = s.parent)

    return local
  }

  lookupPartial(name: string) {
    let s: VScope | undefined = this
    // let procsOnly = false
    do {
      for (let i = name.length, partial: string; i >= 1; i--) {
        partial = name.slice(0, i)
        if (s.locals.has(partial)) {
          const local = s.locals.get(partial)!
          // if (!procsOnly || local.type === 'proc') {
          return local
          // }
        }
      }
      if (s.boundary) {
        break
        // procsOnly = true
      }
    } while (s = s.parent)
  }

  // extract<T extends Value['type']>(type: T) {
  //   const results: Value<T>[] = []
  //   const queue: (CstNode | Value)[] = [...this.stack]
  //   while (queue.length) {
  //     const item = queue.shift()!
  //     if (item.type === type) results.push(item as any)
  //     if ('stack' in item && item.stack && item.stack.length) queue.push(...item.stack)
  //   }
  //   return results
  // }

  push(value: Value) {
    // console.log('PUSH', value)
    this.stack.push(value)
  }

  peek(): Value | false {
    // climb up scope to pull from the stack
    let s: VScope | undefined = this
    do {
      if (s.stack.length) break
    } while (s = s.parent)

    if (!s || !s.stack.length) {
      return false
    }

    return s.stack.at(-1)!
  }

  peekType(op: AstNode, types: ValueType[]): Value | false {
    const useId = op.text === '='

    // climb up scope to pull from the stack
    let s: VScope | undefined = this
    do {
      // console.log([...s.stack], op.text)
      // if (!s.parent) break
      if (filter(s.stack, types, useId).length) break
    } while (s = s.parent)

    if (!s || !filter(s.stack, types, useId).length) {
      // console.log('HERE', useId, op.text, s && [...s.stack])
      return false
    }

    const needId = useId && types.length === 1 && types[0] === 'id'

    let value!: Value
    for (let i = s.stack.length - 1; i >= 0; i--) {
      value = s.stack[i]
      if (needId && value.meta.local) return value.meta.local
      else if (types.includes(value.type)) {
        return value
      }
    }
    return false
  }

  pop(id?: AstNode, op?: AstNode<'op'>, types?: ValueType[], climb = true): Value {
    const useId = op?.text === '='
    // climb up scope to pull from the stack
    let s: VScope | undefined = this

    if (climb) do {
      if (filter(s.stack, types, useId).length) break
      if (id?.text !== 'in' && s.boundary) break
    } while (s = s.parent)

    if (!s || !filter(s.stack, types, useId).length) {
      if (id) {
        raise(`Expect value in the stack for "${id.text}".`, this)
      }
      else {
        raise('Empty stack!', this)
      }
    }

    if (!s) throw new Error('unreachable')

    const needId = useId && types?.length === 1 && types[0] === 'id'

    let value!: Value
    let index: number = -1
    if (types) {
      for (let i = s.stack.length - 1; i >= 0; i--) {
        value = s.stack[i]
        if (needId && value.meta.local) {
          index = i
          value = value.meta.local
          break
        }
        else if (types.includes(value.type)) {
          index = i
          break
        }
      }
    }
    else {
      value = s.stack.pop()!
      return value
    }

    if (index >= 0) {
      s.stack.splice(index, 1)
    }
    else {
      value = s.stack.at(-1)!
      raise(`Expected one of types "${types}" for label "${id!.text}", but this is type "${value.type}".`, this)
    }

    return value
  }

  pushScope(boundary = false) {
    return new VScope(this.emitter, this, boundary)
  }

  flushLabel() {
    if (!this.labelReceiver) return

    // console.log('RECEIVERRRR', this.labelReceiver)
    const value = this.pop(this.labelReceiver)
    this.locals.set(this.labelReceiver.text, value)
    // console.log('SET', this.labelReceiver.text, value)
    this.labelReceiver = null
  }

  climbAdd<T extends 'audios' | 'scalars'>(kind: T, node: GetSetU<VScope[T]>) {
    let s: VScope | undefined = this
    do { s[kind].add(node as any) } while (s = s.parent)
  }

  climbSet<T extends 'gens' | 'literals'>(kind: T, key: GetMapUV<VScope[T]>[0], value: GetMapUV<VScope[T]>[1]) {
    let s: VScope | undefined = this
    do { s[kind].set(key as any, value as any) } while (s = s.parent)
  }

  audio(cstNode: AstNode) {
    const ptr = this.top.audios.size

    const node: VAudio = Object.assign(
      Object.create(null),
      cstNode,
      {
        callers: Array.from(this.lookup<VList<Caller>>('callers', true)?.items ?? []),
        type: 'audio',
        code: `o${ptr}`,
        ptr,
        meta: { ...cstNode.meta },
      })

    this.top.audios.add(node)
    // this.climbAdd('audios', node)

    return node
  }

  scalar(cstNode: AstNode = Node) {
    const ptr = this.top.scalars.size

    const node: VScalar = Object.assign(
      Object.create(null),
      cstNode,
      {
        type: 'scalar',
        code: `s${ptr}`,
        ptr,
        // meta: { ...cstNode.meta },
      })

    // const node: VScalar = {
    //   ...cstNode,
    //   type: 'scalar',
    //   code: `s${ptr}`,
    //   ptr,
    // }

    this.top.scalars.add(node)
    // this.climbAdd('scalars', node)

    return node
  }

  literal(cstNode: AstNode) {
    const ptr = this.top.literals.size
    const info = parseNumber(cstNode.text)

    const node: VLiteral = Object.assign(
      Object.create(null),
      cstNode,
      info,
      {
        type: 'literal',
        code: `l${ptr}`,
        tokens: [cstNode],
        ptr,
        // meta: { ...cstNode.meta },
      }
    )

    // {
    //   ...cstNode,
    //   type: 'literal',
    //   ...info,
    //   code: `l${ptr}`,
    //   tokens: [cstNode],
    //   ptr,
    // }

    this.top.literals.set(cstNode as AstNode<'number'>, node)
    // this.climbSet('literals', cstNode as CstNode<'number'>, node)

    return node
  }
}

const Node: AstNode = {
  type: 'id',
  tokens: [],
  stack: [],
  text: '',
  line: 0,
  col: 0,
  right: 0,
  bottom: 0,
  index: 0,
  meta: {}
}

/*
 *
 * parse ->  proc
 *
 * parse ->  scoped
 *           -> create callers
 *           -> create caller (view) add to callers
 *           -> visit proc.stack
 *              -> create gen
 *                 -> scoped
 *                    -> get callers
 *                    -> create caller (view) add to callers
 *                    -> visit proc.stack
 *                       -> create gen
 *
 *
 *
 *
 */


function cast(params: string[], x: string) {
  return `${params[1] !== 'f32' && (
    x.startsWith('s')
    || x.startsWith('l')
  ) ? `to_${params[1]} ` : ''}${x}`
}

const visitors: Partial<CstVisitors<VScope>> = {
  native(node, v) {
    node = Object.assign(Object.create(null), node)
    const ptr = v.top.gens.size
    const kind = node.text

    const gen: Gen = {
      kind,
      callers: Array.from(v.lookup<VList<Caller>>('callers', true)?.items ?? []),
      locals: {},
      tokens: [],
      code: `g${ptr}`,
      ptr,
    }

    function set(id: string, x: string) {
      const code = `${id}(${gen.code},${x})`
      gen.locals[id] = x
      // console.log('SET', id, gen.code, x)
      v.emitter.emit(code)
    }

    v.top.gens.set(node, gen)
    // v.climbSet('gens', node, gen)

    // // TODO: we can get early freesound id info here from the local literal
    // if (gen.kind === 'say') {
    //   console.log(v.locals)
    // }

    // console.log(envGens[kind])
    // update gen locals
    let updated = 0
    // if (kind === 'lp') console.log(...v.locals)
    outer: for (const localInfo of envGens[kind]) {
      const label = localInfo.label

      let local: Value | undefined

      if (v.locals.has(label)) {
        local = v.locals.get(label)
        if (local && local.tokens.some(inPreludeTokens)) {
          const value = v.parent!.lookup(label, true)
          if (!value) continue outer
          local = value
        }
      }
      else {
        local = v.lookup(label, true)
      }

      if (!local) continue

      gen.tokens.push(local)

      const { id, params, range } = localInfo
      const localType = types[label]?.[0] ?? 'scalar'

      // function set(x: string, id: string, gen: Gen, v: VScope) {
      //   const code = `${id}(${gen.code},${x})`
      //   gen.locals[id] = x
      //   // console.log('SET', id, gen.code, x)
      //   v.emitter.emit(code)
      // }

      // console.log('GOT', local)

      if (isType('id', local)) {
        const value = v.lookup(local.text)
        if (value == null) continue
        local = value
      }

      if (isType('string', local)) {
        gen.locals[id] = local.text.slice(1, -1)
      }
      else if (range) {
        const [min, max] = range
        const minmax = `${typeof min === 'number' ? float(min) : min},${typeof max === 'number' ? float(max) : max}`

        if (isType('list', local)) {
          local = local.items.at(-1)!
        }

        if (local.type === 'scalar' || local.type === 'literal') {
          set(id, cast(params, `clamp(${minmax},${local.code})`))
        }
        else if (local.type === 'audio') {
          v.emitter.emit(`ab=${local.code}>>2`)
          set(id, cast(params, `clamp(${minmax},ab[begin])`))
        }
      }
      else {
        if (isType('list', local)) {
          local = local.items.at(-1)!
        }

        if (isType('scalar', local) || isType('literal', local)) {
          for (const t of local.tokens) {
            // TODO: unless it was and then removed?
            if (preludeTokens.has(t)) {
              continue outer
            }
          }

          if (!['scalar', 'literal'].includes(localType)) {
            if (localType === 'audio') {
              unaryScalarOp({ ...node, type: 'op', text: 'to_audio' }, local, v)
              local = v.pop() as VAudio
            }
            else {
              raise(`Expected type "${localType}" but got "${local.type}".`, v)
            }
          }

          // if (0 === local.value) continue
          set(id, cast(params, local.code))
        }
        else if (isType('audio', local)) {
          if (audioLabels.includes(label)) {
            set(id, local.code)
          }
          else {
            v.emitter.emit(`ab=${local.code}>>2`)
            set(id, cast(params, `ab[begin]`))
          }
        }
      }

      v.top.used.add(local)
      updated++
    }

    // console.log(kind, v.locals)
    if (updated) {
      const update = envLookupMethod(kind, 'update')
      if (update) {
        const code = `${update}(${gen.code})`
        v.emitter.emitUpdate(code)
        v.emitter.emit(code)
      }
      // NOTE: Special case - rate changes audiorate so we need to
      // update these values in the executor's context as well
      // because they are used.
      if (kind === 'rate') {
        v.emitter.emit('ar=rates[0]')
        v.emitter.emit('arf=to_f32 ar')
      }
    }

    const audioMethod = envLookupMethod(kind, 'audio')

    if (audioMethod) {
      const audio = v.audio(node)
      v.emitter.emit(`${audioMethod}(${gen.code},begin,i,${audio.code}) // ${kind}`)
      gen.audio = audio
      v.push(audio)
    }
  },

  scoped(node, v) {
    let key = callerKeys.get(node)
    if (!key) callerKeys.set(node, key = randomId())
    // console.log(node)

    const caller: Caller = Object.assign(
      Object.create(null),
      node,
      { key, ref: node }
    )

    const scope = v.pushScope(true)
    visitStack(caller.stack, scope)
    scope.flushLabel()

    let callers: VList | undefined = scope.lookup<VList>('callers', true)

    if (!callers) {
      callers = Object.assign(
        Object.create(null),
        Node,
        {
          type: 'list',
          items: [caller],
        }
      )
      callers = callers! // ts wtf
      scope.locals.set('callers', callers)
    }
    else {
      // scope.locals.set('callers', { ...callers, items: [...callers.items, caller] })
      callers.items.push(caller)
    }

    let proc: VProc | undefined

    try {
      proc = scope.pop(void 0, void 0, ['proc'], false) as VProc
    }
    catch (error) {
      if (!(error as Error).message.includes('Empty stack')) {
        console.error(error)
      }
    }

    if (!proc) {
      const id: VNode<'id'> | undefined = scope.stack.find((item) =>
        isType('id', item)
      ) as VNode<'id'>

      if (id) {
        const items = [
          'sin', 'sin', 'sin', 'sin', 'sin', 'sin',
          'exp', 'exp', 'exp', 'blp', 'bhp', 'lp', 'bbp', 'bpk'
        ]
        const matches = items.filter((x) => x.startsWith(id.text))
        return raise(`Unknown procedure "${id.text}". ${matches.length ? `Perhaps: ${[...new Set(matches)].join(', ')}.` : `Try "${items[Math.random() * items.length | 0]}".`}`, v)
      }

      // if (id) return raise(`Unknown procedure "${id.text}". Try: "${[]}"`, v)
      // return v.raise('Enter a procedure, e.g "sin".')
    }

    let procScope: VScope | undefined

    if (proc) {
      procScope = scope.pushScope()
      visitStack(proc.stack, procScope)

      if (procScope?.placeholders?.size) {
        // console.log(procScope)

        procScope.placeholders.forEach((audio, id) => {
          const last = procScope!.locals.get(id)
          // console.log('LAST', last)
          if (!last) return

          // console.log(v.top.emitter.code)
          v.emitter.code.forEach((x, i) => {
            if (x.includes(`${(audio as VAudio).code},`)) {
              v.emitter.code[i] = x.replace(
                `${(audio as VAudio).code},`,
                `${(last as VAudio).code},`
              )
              // console.log('YEA', x)
            }
          })
        })
      }
    }

    callers.items.pop()

    const stack = proc ? procScope!.stack : scope.stack


    // if (procScope?.placeholders?.size) {
    //   console.log('YES', procScope.placeholders)
    // }
    // v.top.emitter.code.forEach((s) => {
    //   // console.log('YES', s)
    // })

    const last = stack.at(-1)

    // console.log('LAST IS', last, procScope, scope)
    // console.log('PROC', procScope)
    // console.log('>>>', ...node.stack, ...stack)
    if (last) {
      if (isType('literal', last) && v.top.params.has(last)) {
        const param = v.top.params.get(last)!
        let min, max, slope, step
        if (stack.length > 1 && !scope.lookupPartial('min')) min = stack.shift()
        if (stack.length > 1 && !scope.lookupPartial('max')) max = stack.shift()
        if (stack.length > 1 && !scope.lookupPartial('slope')) slope = stack.shift()
        if (stack.length > 1 && !scope.lookupPartial('step')) step = stack.shift()
        // TODO: handle other types than literal
        if (min && isType('literal', min)) param.min = min.value
        if (max && isType('literal', max)) param.max = max.value
        if (slope && isType('literal', slope)) param.slope = slope.value
        if (step && isType('literal', step)) param.step = step.value
        param.nodes.push(...[min, max, slope, step].filter(Boolean))

        let lastValue = v.stack.at(-1) as VAudio | undefined
        if (lastValue?.tokens?.[0]?.text !== '@') {
          lastValue = void 0
        }
        param.last = lastValue
      }

      // console.log('PUSH', last)
      // if (isType('audio', last)) {
      //   last.caller = caller
      // }

      v.push(last)
    }
  },
  label(node, v) {
    v.flushLabel()

    // console.log('LABEL', node)
    if (!v.boundary && v.parent) {
      const local = v.parent.lookupPartial(node.text)
      // console.log(name.text, local)
      if (local) {
        local.meta.local = node
        v.labelReceiver = node

        // console.log('GOT LOCALLLLL', local, node.text)
        let value: Value | undefined

        if (local.type === 'id') {
          value = v.lookup(local.text, true)
        }
        else {
          value = local
        }

        if (audioLabels.includes(node.text) && (!value || value.type !== 'audio')) {
          if (value && isType('list', value)) {
            value = value.items.at(-1)!
          }
          if (!value || value.type !== 'audio') {
            raise('Expected audio.', v)
          }
        }

        // v.push(local)
        // console.log('fill', name.text, local)

        // local.meta.name = name.text
        v.locals.set(node.text, local)

        return
      }
    }

    // console.log('RECEIVER', node, node.text)
    v.labelReceiver = node
  },
  proc(node, v) {
    v.push(node)
    v.flushLabel()
  },
  prog(node, v) {
    visitStack(node.stack, v)
  },
  number(node, v) {
    if (v.top.literals.has(node)) {
      v.push(v.top.literals.get(node)!)
      return
    }
    const value = v.literal(node)
    v.push(value)
  },
  array(node, v) {
    const scope = v.pushScope()

    visitStack(node.stack, scope)

    const value: VList = {
      ...node,
      type: 'list',
      items: scope.stack,
    }

    v.push(value)
  },
  id(node, v) {
    let local: Value | undefined

    // lookup value only if the next operation in the stack
    // is not an assignment operation

    // TODO: skip this and instead assign the id into the value's .localId
    // so it can be used instead of the value at assignment operations later

    // const isNextOp = next?.type === 'op'
    // const isNextAssignment = isNextOp && next.text === '='

    // if (!isNextAssignment) {
    // console.log('SEARCH FOR', node.text)
    local = v.lookup(node.text, true)
    if (local && local.type !== 'proc') {
      // console.log('GOT LOCAL', node.text, local)
      local.meta.local = node
    }
    // }

    v.push(local ?? node)
  },
  op(op, v) {
    if (helpers.isBinaryOp(op)) {
      // console.log('OP', op, v.scope)
      let rhs: Value
      let lhs: Value

      if (op.text === '=') {
        if (v.peek() && (v.peek() as Value).type !== 'id' && v.peekType(op, ['list'])) {
          const list = v.pop(op.owner, op, ['list']) as VList
          for (const item of list.items) {
            if (item.meta.local) {
              v.locals.set(item.meta.local.text, item)
            }
          }
          return
        }
        // if (v.labelReceiver) {
        //   console.log('YES', v.peek())
        //   if (!v.peek()) {
        //     v.labelReceiver = null
        //     return
        //   }
        // }

        if (!v.labelReceiver && !v.peekType(op, ['id'])) {
          console.log('not an id', op)
          return
        }

        // console.log('LABEL RECEIVER', v.labelReceiver)
        // if (!v.labelReceiver && op.owner?.type === 'proc') {
        //   debugger
        // }
        if (v.labelReceiver) {
          // console.log(v.labelReceiver.text, v.lookup(v.labelReceiver.text, true))
          if (v.lookup(v.labelReceiver.text, true)) {
            v.labelReceiver = null
            return
          }
          lhs = v.labelReceiver as unknown as VNode<'id'>
        }
        else {
          // console.log(op.owner)
          if (op.owner?.type !== 'id' && op.owner?.meta.local) {
            op.owner = op.owner.meta.local
          }
          lhs = v.pop(op.owner, op, ['id']) as VNode<'id'>
        }

        // console.log('WILL POP', ...v.stack, op)
        rhs = v.pop(lhs, op, types[lhs.text])

        // console.log('ASSIGN TO', lhs, rhs)

        // console.log(lhs.text, op.text, rhs.text)

        v.labelReceiver = null
      }
      else {
        rhs = v.pop(op)
        lhs = v.pop(op)
      }

      // console.log(lhs.text, op.text, rhs.text)

      const rhsType = rhs.type as BinaryOpRhsType
      const lhsType = lhs.type as BinaryOpLhsType
      if (lhsType in BinaryOp && rhsType in BinaryOp[lhsType]) {
        // @ts-ignore
        BinaryOp[lhsType][rhsType](op, lhs, rhs, v)
      }
      else {
        // console.log(lhs, rhs)
        raise(`No binary operation for types: lhs=${lhsType}${isType('id', lhs) ? `("${lhs.text}")` : ''} rhs=${rhsType}.`, v)
      }
      // do binary op
      // v.push(v.binaryOp(op, lhs, rhs))
      // const scalar = v.scalar()

      //v.emit()
      // ir.push(result)
    }
    else if (helpers.isUnaryOp(op)) {
      const lhs = v.pop(op.owner)
      const lhsType = lhs.type as UnaryOpType
      if (lhsType in UnaryOp) {
        // @ts-ignore
        UnaryOp[lhsType](op, lhs, v)
      }
      else {
        raise(`No unary operation for type: ${lhsType}.`, v)
      }
    }
    else if (helpers.isTernaryOp(op)) {
      const c = v.pop(op)
      const b = v.pop(op)
      const a = v.pop(op)

      const aType = a.type as TernaryOpAType
      const bType = b.type as TernaryOpBType
      const cType = c.type as TernaryOpCType
      if (aType in TernaryOp && bType in TernaryOp[aType] && cType in TernaryOp[aType][bType]) {
        TernaryOp[aType][bType][cType](
          op,
          a as Value & { type: typeof aType },
          // @ts-ignore wtf
          b as Value & { type: typeof bType },
          c as Value & { type: typeof cType },
          v
        )
      }
    }
    else {
      switch (op.text) {
        case ',':
          v.flushLabel()
          break

        case '@': {
          visit(zero, v)
          let rhs = v.pop() as VAudio
          let lhs: Value
          while (v.stack.length) {
            lhs = v.pop()
            if (isType('audio', lhs)) {
              BinaryOp.audio.audio(Object.assign(
                Object.create(null),
                op,
                { tokens: [op], text: '+' }
              ), lhs, rhs, v)
              rhs = v.pop() as VAudio
            }
          }
          v.push(rhs)
          break
        }

        default:
          raise('Weird operation.', v)
      }
    }
  },
}

function visit<T extends AstNodeType>(node: AstNode<T>, v: VScope, next?: AstNode<T> | null) {
  v.nodes.add(node)
  if (node.type in visitors) visitors[node.type]!(node, v, next)
  else v.stack.push(node as Value)
}

function visitStack(stack: AstNode[], v: VScope) {
  for (let i = 0, node: AstNode, next: AstNode | null; i < stack.length; i++) {
    node = stack[i]
    next = i < stack.length - 1 ? stack[i + 1] : null
    visit(node, v, next)
  }
}

function isType<T extends ValueType>(type: T, node: Value): node is Value & { type: T } {
  return node.type === type
}

const ternaryOps = new Set('slide'.split(/\s+/))
const binaryOps = new Set('+ - * / ^ % = pick'.split(/\s+/))
const unaryOps = new Set('! \\ floor to_audio'.split(/\s+/))
const helpers = {
  isTernaryOp(op: { text: string }) {
    return ternaryOps.has(op.text)
  },
  isBinaryOp(op: { text: string }) {
    return binaryOps.has(op.text)
  },
  isUnaryOp(op: { text: string }) {
    return unaryOps.has(op.text)
  }
}

type TernaryOpAType = 'list'
type TernaryOpBType = 'literal' | 'scalar'
type TernaryOpCType = 'literal' | 'scalar'

type BinaryOpLhsType = 'label' | 'literal' | 'list' | 'scalar' | 'audio' | 'id'
type BinaryOpRhsType = 'literal' | 'list' | 'scalar' | 'audio' | 'id' | 'string'

const Op = {
  '*': 'mul',
  '/': 'div',
  '+': 'add',
  '-': 'sub',
  '^': 'pow',
  '%': 'mod',
  '!': 'not',
  'floor': 'floor',
  'pick': 'pick',
  'slide': 'slide',
  'to_audio': 'to_audio',
} as any

const primitiveScalarOps = new Set('+ - * /'.split(/\s+/))

function list_scalar(op: AstNode<'op'>, lhs: VList, rhs: VLiteral | VScalar, v: VScope) {
  const newList: VList = { ...lhs, items: [] }
  for (let item of lhs.items) {
    const actualItem = item
    let lhsType = item.type as BinaryOpLhsType
    const rhsType = rhs.type as BinaryOpRhsType
    // if (op.text === '=') {
    //   console.log('FUCKK')
    //   if (item.meta.local) {
    //     item = item.meta.local
    //     lhsType = item.type as BinaryOpLhsType
    //   }
    // }
    if (lhsType in BinaryOp && rhsType in BinaryOp[lhsType]) {
      // @ts-ignore
      BinaryOp[lhsType][rhsType](op, item, rhs, v)
      const last = v.pop()
      if (actualItem.meta.local) {
        last.meta.local = actualItem.meta.local
      }
      newList.items.push(last)
    }
    else {
      raiseInvalidBinaryOp(op, item, rhs, v)
    }
  }
  v.push(newList)
}

function scalar_scalar(op: AstNode<'op'>, lhs: VLiteral | VScalar, rhs: VLiteral | VScalar, v: VScope) {
  v.top.used.add(lhs)
  v.top.used.add(rhs)

  const scalar = v.scalar()

  if (op.text === '^') {
    v.emitter.emit(`s${scalar.ptr} = pow_scalar_scalar(${lhs.code},${rhs.code})`)
  }
  else if (op.text === '%') {
    v.emitter.emit(`s${scalar.ptr} = to_f32 mod(to_f64 ${lhs.code},to_f64 ${rhs.code})`)
  }
  else if (primitiveScalarOps.has(op.text)) {
    v.emitter.emit(`s${scalar.ptr} = ${lhs.code} ${op.text} ${rhs.code}`)
  }
  else {
    raiseInvalidBinaryOp(op, lhs, rhs, v)
  }

  v.push(scalar)
}

function audio_scalar(op: AstNode<'op'>, lhs: VAudio | VLiteral | VScalar, rhs: VAudio | VLiteral | VScalar, v: VScope) {
  v.top.used.add(lhs)
  v.top.used.add(rhs)

  let S_A = `${Op[op.text]}_scalar_audio`
  let A_S = `${Op[op.text]}_audio_scalar`

  if (rhs.type === 'audio') {
    [S_A, A_S] = [A_S, S_A];
  }

  // if (op.text === '/') {
  //   console.log(lhs, rhs)
  // }
  const audio = v.audio(op)
  if (A_S in envTypes) {
    v.emitter.emit(`${A_S}(${lhs.code},${rhs.code},begin,i,${audio.code}) // ${audio.text}`)
  }
  else if (S_A in envTypes) {
    v.emitter.emit(`${S_A}(${rhs.code},${lhs.code},begin,i,${audio.code}) // ${audio.text}`)
  }
  else {
    raiseInvalidBinaryOp(op, lhs, rhs, v)
  }

  if (isType('literal', rhs) && v.top.params.has(rhs) && op.text === '*') {
    const param = v.top.params.get(rhs)!
    param.last = audio
    param.nodes.push(audio)
  }

  v.push(audio)
}

function assignment(op: AstNode<'op'>, lhs: VNode<'id'>, rhs: Value, v: VScope) {
  v.top.used.add(lhs)
  v.top.used.add(rhs)

  // console.log('ASSIGN', lhs, rhs)
  if (op.text === '/') console.log(op, lhs, rhs)
  if (op.text === '=') {
    if (isType('literal', rhs)) {
      // assign literal to scalar so it's correctly identified when the variable is used
      const scalar = v.scalar()
      v.emitter.emit(`s${scalar.ptr} = ${rhs.code} // ${lhs.text}`)
      v.locals.set(lhs.text, scalar)
    }
    else {
      // console.log('YO', lhs.text, rhs)
      v.locals.set(lhs.text, rhs)
    }
  }
  else if (lhs.type === 'id' || lhs.type === 'label') {
    let value = v.lookup(lhs.text, true)
    // if (v.placeholders.has(lhs.text)) {
    //   console.log('IN PLACEHOLDERS', lhs.text, v.placeholders.get(lhs.text), rhs)
    // }
    if (!value) {
      const audio = v.audio(lhs)
      v.locals.set(lhs.text, audio)
      v.placeholders.set(lhs.text, audio)
      // console.log('ADD TO PLACEHOLDERS AGAINN', lhs.text)
      value = audio
      // raiseInvalidBinaryOp(op, lhs, rhs, v)
      // return
    }
    const lhsType = value.type as BinaryOpLhsType
    const rhsType = rhs.type as BinaryOpRhsType
    if (lhsType in BinaryOp && rhsType in BinaryOp[lhsType]) {
      // @ts-ignore
      BinaryOp[lhsType][rhsType](op, value, rhs, v)
    }
    else {
      // console.log(value, rhs)
      // throw new Error(`No binary operation for types: lhs=${lhsType} rhs=${rhsType}.`)
      raiseInvalidBinaryOp(op, value, rhs, v)
    }
  }
  else {
    raiseInvalidBinaryOp(op, lhs, rhs, v)
  }
}

function pickOp(op: AstNode<'op'>, lhs: VList, rhs: VScalar | VLiteral, v: VScope) {
  const scalar = v.scalar(op)
  scalar.tokens = Array.from(lhs.items)
  v.top.used.add(rhs)
  let i = v.top.listItems
  const ptr = i
  for (const item of lhs.items) {
    if (isType('scalar', item) || isType('literal', item)) {
      v.top.used.add(item)
      if (isType('literal', item)) {
        v.emitter.emitList(`l[${i}]=${item.code}`)
      }
      else {
        v.emitter.emit(`l[${i}]=${item.code}`)
      }
      i = ++v.top.listItems
    }
  }
  v.emitter.emit(`li=floor(modf(${rhs.code},${(i - ptr) | 0}.0)) // pick ${lhs.text}`)
  v.emitter.emit(`s${scalar.ptr}=l[${ptr > 0 ? `${ptr} + ` : ''}(to_i32 li)]`)
  v.emitter.emit(`se[${scalar.ptr}]=li`)
  v.push(scalar)
}

function slideOp(op: AstNode<'op'>, a: VList, b: VScalar | VLiteral, c: VScalar | VLiteral, v: VScope) {
  const scalar = v.scalar(op)
  scalar.tokens = Array.from(a.items)
  v.top.used.add(b)
  v.top.used.add(c)
  let i = v.top.listItems
  const ptr = i
  for (const item of a.items) {
    if (isType('scalar', item) || isType('literal', item)) {
      v.top.used.add(item)
      if (isType('literal', item)) {
        v.emitter.emitList(`l[${i}]=${item.code}`)
      }
      else {
        v.emitter.emit(`l[${i}]=${item.code}`)
      }
      i = ++v.top.listItems
    }
  }

  v.emitter.emit(`lp=modf(${b.code},${(i - ptr) | 0}.0) // slide pos`)
  v.emitter.emit(`li=floor(lp) // slide index`)
  v.emitter.emit(`ln=floor(modf(lp+1.0,${(i - ptr) | 0}.0)) // slide next`)
  v.emitter.emit(`sn=l[${ptr > 0 ? `${ptr} + ` : ''}(to_i32 li)]`)
  v.emitter.emit(`s${scalar.ptr}=sn+(l[${ptr > 0 ? `${ptr} + ` : ''}(to_i32 ln)]-sn)*pow_scalar_scalar(lp-li,${c.code})`)
  v.emitter.emit(`se[${scalar.ptr}]=li`)
  v.push(scalar)
}

const TernaryOp: { [A in TernaryOpAType]: { [B in TernaryOpBType]: { [C in TernaryOpCType]: (op: AstNode<'op'>, a: Value & { type: A }, b: Value & { type: B }, c: Value & { type: C }, v: VScope) => void } } } = {
  list: {
    literal: {
      literal(op, a, b, c, v) {
        if (op.text === 'slide') {
          slideOp(op, a, b, c, v)
        }
        else {
          raise('No ternary operation for: ' + op.text, v)
        }
      },
      scalar(op, a, b, c, v) {
        if (op.text === 'slide') {
          slideOp(op, a, b, c, v)
        }
        else {
          raise('No ternary operation for: ' + op.text, v)
        }
      }
    },
    scalar: {
      literal(op, a, b, c, v) {
        if (op.text === 'slide') {
          slideOp(op, a, b, c, v)
        }
        else {
          raise('No ternary operation for: ' + op.text, v)
        }
      },
      scalar(op, a, b, c, v) {
        if (op.text === 'slide') {
          slideOp(op, a, b, c, v)
        }
        else {
          raise('No ternary operation for: ' + op.text, v)
        }
      }
    }
  }
}

const BinaryOp: { [L in BinaryOpLhsType]: { [R in BinaryOpRhsType]: (op: AstNode<'op'>, lhs: Value & { type: L }, rhs: Value & { type: R }, v: VScope) => void } } = {
  id: {
    literal: assignment,
    scalar: assignment,
    audio: assignment,
    list: assignment,
    id: assignment,
    string: assignment,
  },
  label: {
    literal: assignment,
    scalar: assignment,
    audio: assignment,
    list: assignment,
    id: assignment,
    string: assignment,
  },
  audio: {
    literal: audio_scalar,
    scalar: audio_scalar,
    audio(op, lhs, rhs, v) {
      const audio = v.audio(op)
      const A_A = `${Op[op.text]}_audio_audio`
      if (A_A in envTypes) {
        v.emitter.emit(`${A_A}(${lhs.code},${rhs.code},begin,i,${audio.code}) // ${audio.text} ${lhs.text}`)
        v.push(audio)
      }
      else {
        raiseInvalidBinaryOp(op, lhs, rhs, v)
      }
    },
    list(op, lhs, rhs, v) {
      raiseInvalidBinaryOp(op, lhs, rhs, v)
    },
    id(op, lhs, rhs, v) {
      const audio = v.audio(rhs)
      v.locals.set(rhs.text, audio)
      v.placeholders.set(rhs.text, audio)
      // console.log('ADD TO PLACEHOLDERS', rhs.text)
      return BinaryOp.audio.audio(op, lhs, audio, v)
    },
    string(op, lhs, rhs, v) {
      raiseInvalidBinaryOp(op, lhs, rhs, v)
    },
  },
  literal: {
    literal: scalar_scalar,
    scalar: scalar_scalar,
    audio: audio_scalar,
    list(op, lhs, rhs, v) {
      raiseInvalidBinaryOp(op, lhs, rhs, v)
    },
    id(op, lhs, rhs, v) {
      raiseInvalidBinaryOp(op, lhs, rhs, v)
    },
    string(op, lhs, rhs, v) {
      raiseInvalidBinaryOp(op, lhs, rhs, v)
    },
  },
  scalar: {
    literal: scalar_scalar,
    scalar: scalar_scalar,
    audio: audio_scalar,
    list(op, lhs, rhs, v) {
      raiseInvalidBinaryOp(op, lhs, rhs, v)
    },
    id(op, lhs, rhs, v) {
      raiseInvalidBinaryOp(op, lhs, rhs, v)
    },
    string(op, lhs, rhs, v) {
      raiseInvalidBinaryOp(op, lhs, rhs, v)
    },
  },
  list: {
    literal(op, lhs, rhs, v) {
      if (op.text === 'pick') {
        pickOp(op, lhs, rhs, v)
      }
      else {
        list_scalar(op, lhs, rhs, v)
      }
    },
    scalar(op, lhs, rhs, v) {
      if (op.text === 'pick') {
        pickOp(op, lhs, rhs, v)
      }
      else {
        list_scalar(op, lhs, rhs, v)
      }
    },
    list(op, lhs, rhs, v) {
      raiseInvalidBinaryOp(op, lhs, rhs, v)
    },
    audio(op, lhs, rhs, v) {
      raiseInvalidBinaryOp(op, lhs, rhs, v)
    },
    id(op, lhs, rhs, v) {
      raiseInvalidBinaryOp(op, lhs, rhs, v)
    },
    string(op, lhs, rhs, v) {
      raiseInvalidBinaryOp(op, lhs, rhs, v)
    },
  },
}

function unaryScalarOp(op: AstNode<'op'>, value: VLiteral | VScalar, v: VScope) {
  v.top.used.add(value)

  if (op.text === 'floor') {
    const scalar = v.scalar()
    v.emitter.emit(`s${scalar.ptr} = floor(${value.code})`)
    v.push(scalar)
  }
  else if (op.text === 'to_audio') {
    const audio = v.audio(op)
    v.emitter.emit(`to_audio_scalar(${value.code},begin,i,${audio.code}) // ${audio.text} ${value.text}`)
    v.push(audio)
  }
  else {
    raise('No unary operation found for: ' + op.text, v)
  }
}

type UnaryOpType = 'audio' | 'literal' | 'scalar' | 'list' | 'string' | 'special'

const UnaryOp: { [K in UnaryOpType]: (op: AstNode<'op'>, value: Value & { type: K }, v: VScope) => void } = {
  audio(op, value, v) {
    const audio = v.audio(op)
    const A = `${Op[op.text]}_audio`
    if (A in envTypes) {
      v.emitter.emit(`${A}(${value.code},begin,i,${audio.code}) // ${audio.text} ${value.text}`)
      v.push(audio)
    }
    else {
      raise('No unary operation for: ' + op.text, v)
    }
  },
  string(op, value, v) {
    switch (op.text) {
      case '\\': {
        const sliderName = value
        op.meta.sliderName = sliderName

        const next = v.pop()
        if (isType('literal', next)) {
          UnaryOp.literal(op, next, v)
        }
        else {
          raise(`Expected type "literal" but got "${next.type}".`, v)
        }
        break
      }

      default:
        raise('No unary operation for: ' + op.text, v)
    }
  },
  special(op, value, v) {
    switch (op.text) {
      case '\\': {
        const special = value
        // TODO: examine special.text for relevant (M|S)
        op.meta[special.text] = special

        const next = v.pop()
        if (isType('string', next)) {
          UnaryOp.string(op, next, v)
        }
        else if (isType('special', next)) {
          UnaryOp.special(op, next, v)
        }
        else {
          raise(`Expected type "string | special" but got "${next.type}".`, v)
        }
        break
      }

      default:
        raise('No unary operation for: ' + op.text, v)
    }
  },
  literal(op, value, v) {
    switch (op.text) {
      case '\\': {
        if (!v.params.has(value)) {
          const ranges: [number, number][] = [
            [0, 0.999999],
            [1, 9.999999],
            [10, 99.99999],
            [100, 999.9999],
            [1_000, 9_999.99],
            [10_000, 99_999.9],
            [100_000, 999_999],
            [1_000_000, 9_999_999],
            [10_000_000, 99_999_999],
            [100_000_000, 999_999_999],
            [Infinity, 1]
          ]

          const rangeIndex = ranges.findIndex(
            (range) =>
              value.value < range[0]
          )

          /** [min,max,step,slope] */
          const range = ranges[rangeIndex - 1]

          const minNode = (v.lookup('min') as VLiteral)
          const maxNode = (v.lookup('max') as VLiteral)
          const stepNode = (v.lookup('step') as VLiteral)
          const slopeNode = (v.lookup('slope') as VLiteral)

          const min = minNode?.value ?? range[0]
          const max = maxNode?.value ?? range[1]
          const step = stepNode?.value ?? (1 / 10 ** value.digits)
          const slope = slopeNode?.value ?? 1

          let last = v.stack.at(-1)
          if (last?.tokens?.[0]?.text !== '@') {
            last = void 0
          }

          const param: Param = {
            target: value,
            op,
            name: op.meta.sliderName,
            mute: op.meta.M,
            solo: op.meta.S,
            min,
            max,
            step,
            slope,
            last: last as VAudio | undefined,
            nodes: [op, value, minNode, maxNode, stepNode, slopeNode, last].filter(Boolean)
          }
          value.meta.param = param

          v.top.used.add(value)
          v.top.used.add(minNode)
          v.top.used.add(maxNode)
          v.top.used.add(stepNode)
          v.top.used.add(slopeNode)
          v.top.params.set(value, param)
        }

        v.push(value)
        break
      }

      default:
        unaryScalarOp(op, value, v)
    }
  },
  scalar: unaryScalarOp,
  list(op, value, v) {
    raise('No unary operation found for: ' + op.text, v)
  },
}

export interface Info {
  ins: number
  outs: number
  L: number
  R: number
  cst: AstNode<'prog'>
  scope: VScope
}

let prelude: string
export let pre: VScope
export let preludeTokens: Set<Token | AstNode>

export function inPreludeTokens(t: AstNode) {
  return preludeTokens.has(t)
}

export function produce(cst: AstNode<'prog'>): Info {
  if (!prelude) {
    prelude = Object.entries(envGens).map(([key, labels]) =>
      `
${key}: {
  ${labels.map(({ label, stack, range }) =>
        `${label}:${stack ? '=' : (range ? range[2] : '0')}`
      ).join('\n  ')},
  \`${key}\`
}`
    ).join('\n')
    // console.log(prelude)

    const tokens = [...tokenize(prelude)]
    tokens.forEach((token) => { token.meta.hidden = true })
    const emitter = new Emitter()
    pre = new VScope(emitter)
    const t_literal = pre.literal({ ...Node, text: '0.0', meta: { hidden: true } })
    pre.locals.set('t', t_literal)
    pre.used.add(t_literal)
    pre.locals.set('LR', pre.audio({ ...Node, text: 'LR', meta: { hidden: true } }))
    pre.locals.set('L', pre.audio({ ...Node, text: 'L', meta: { hidden: true } }))
    pre.locals.set('R', pre.audio({ ...Node, text: 'R', meta: { hidden: true } }))
    visit(parse(tokens), pre)
    pre.flushLabel()
    preludeTokens = new Set(tokens)
  }

  // const cst = parse(tokens)
  const emitter = new Emitter()
  const scope = new VScope(emitter)
  scope.used = new Set(pre.used)
  scope.literals = new Map(pre.literals)
  scope.audios = new Set(pre.audios)
  scope.locals = new Map(pre.locals)
  scope.stack = [...pre.stack]
  visit(cst, scope)
  scope.flushLabel()

  // console.log(scope)
  // feedback
  if (scope?.placeholders?.size) {
    scope.placeholders.forEach((audio, id) => {
      const last = scope.locals.get(id)
      if (!last) return

      // console.log(audio)
      emitter.code.forEach((x, i) => {
        if (x.includes(`,${(audio as VAudio).code},`)) {
          emitter.code[i] = x.replace(
            `,${(audio as VAudio).code},`,
            `,${(last as VAudio).code},`
          )
        }
      })
    })
  }
  // v.top.emitter.code.forEach((s) => {
  //   // console.log('YES', s)
  // })


  const postTokens = [...tokenize(`
    [zero] LR+= LR.5* hLR=
    hLR L+=
    hLR R+=
  `)]
  postTokens.forEach((token) => { token.meta.hidden = true })
  visit(parse(postTokens), scope)

  return {
    ins: 2,
    outs: scope.audios.size,
    L: (scope.locals.get('L') as VAudio).ptr,
    R: (scope.locals.get('R') as VAudio).ptr,
    cst,
    scope,
    // diff,
  }
}
