import { lexify } from './compiler/lexer'
import { generateModule } from './compiler/moduleCodeGen'
import { parse as compilerParse } from './compiler/parser'
import { MEM_PAGES } from './constants'
import { Info } from './producer'

export interface Module {
  run(begin: number, end: number): void
  rms(begin: number, end: number, resultsPtr: number): void
  write_literals(): void
  update_gens(): void
  reset(): void
  bench(times: number, begin: number, end: number): void
}

export interface ModuleInstance {
  exports: Module
}

export type CompileEnv = {
  memory: WebAssembly.Memory
  log: (x: number) => void
} & Record<string, WebAssembly.Memory | ((...args: any[]) => any)>

export interface CompilePtrs {
  engine: number
  gens: number[]
  ins: number[]
  outs: number[]
  literals: number
  lists: number
  scalars: number
}

export interface CompileMeta extends CompilePtrs {
  envTypes: Record<string, string>
}

export interface CompileError {
  text: string
  error: Error
}

export interface CompileResult {
  text: string
  binary: Uint8Array
}

export function float(v: number | string): string {
  v = `${v}`
  return v.includes('.')
    ? v.startsWith('.')
      ? `0${v}`
      : v.endsWith('.')
        ? `${v}0`
        : v
    : `${v}.0`
}

export async function compile(info: Info, meta: CompileMeta, debug = false): Promise<CompileResult | CompileError> {
  const namedParams = [...info.scope.params].filter(([, param]) => param.name)
  let hasSolo = false
  for (const [, param] of namedParams) {
    if (param.solo && param.name?.text !== "'main'") {
      hasSolo = true
    }
  }
  const literalValues = new Map()
  for (const [literal, param] of namedParams) {
    literalValues.set(literal,
      (param.solo || !hasSolo || param.name?.text === "'main'") && !param.mute
        ? literal.value
        : 0
    )
  }

  const text = `\
import default_memory 1 ${MEM_PAGES} from "env/memory"
import logi: fn (i32) void from "env/logi"
import logf: fn (f32) void from "env/logf"
import logd: fn (f64) void from "env/logf"

${Object.entries(meta.envTypes).map(([id, type]) =>
    `import ${id}: fn ${type} from "env/${id}"`
  ).join('\n')}

// ins
${Array.from({ length: info.ins }, (_, i) =>
    `i${i}:i32=${meta.ins[i]}`
  ).join('\n')}

// outs
${Array.from(info.scope.audios.values(), (audio, i) =>
    `${audio.code}:i32=${meta.outs[i]}`
  ).join('\n')}

// gens
${Array.from(info.scope.gens.values(), (gen, i) =>
    `${gen.code}:i32=${meta.gens[i]} // ${gen.kind}${gen.audio ? ` -> ${gen.audio.code}` : ''}`
  ).join('\n')}

// scalars
${Array.from(info.scope.scalars, (s) =>
    `${s.code}:f32=0.0`
  ).join('\n')}

// scalars exported
se:ptr f32=${meta.scalars >> 2}

// lists
l:ptr f32=${meta.lists}

// literals
lb:ptr f32=${meta.literals >> 2}

export run
run: fn (i: i32, end: i32) void {
  // audio buffer
  ab:ptr f32=0

  rates: ptr i32 = engine_get_ratesSamples(${meta.engine})>>2
  ar: i32 = rates[0]
  arf: f32 = to_f32 ar

  ${Array.from(info.scope.literals.values())
      .filter(literal => info.scope.used.has(literal))
      .map((literal) =>
        `${literal.code}:f32=lb[${literal.ptr}] // ${literal.value}`
      ).join('\n  ')}

  // l0 is t (time)
  t: f64 = to_f64 l0
  t_step: f64 = (1.0x64 / (to_f64 ar)) * 64.0x64

  // list pointers
  lp:f32=0.0 // pos
  li:f32=0.0 // index
  ln:f32=0.0 // next

  // sample now
  sn:f32=0.0

  // list literals
  ${info.scope.emitter.lists.join('\n  ')}

  loop {
    begin: i32 = i
    i = i + 64

    ${info.scope.emitter.code.join('\n    ')}

    t = t + t_step
    l0 = to_f32 t

    if (i >= end) break
  }

  lb[0] = l0
}

export write_literals
write_literals: fn () void {
  ${Array.from(info.scope.literals.values())
      .filter(literal => info.scope.used.has(literal))
      .map((literal) =>
        `lb[${literal.ptr}]=${float(literalValues.has(literal)
          ? literalValues.get(literal)
          : literal.value
        )}`
      ).join('\n  ')}
}

export rms
rms: fn (begin: i32, end: i32, r: ptr f32) void {
  ${Array.from(info.scope.audios.values()).map((audio) =>
        `r[${audio.ptr}]=rms_(begin,end,${audio.code})`
      ).join('\n  ')}
}

export update_gens
update_gens: fn () void {
  ${info.scope.emitter.updates.join('\n  ')}
}

export reset
reset: fn () void {
  lb[0] = 0.0 // reset time
}

export bench
bench: fn (times: i32, begin: i32, end: i32) void {
  i: i32 = 0

  loop {
    run(begin, end)
    i = i + 1
    if (i >= times) break
  }
}

clamp: fn (min: f32, max: f32, value: f32) f32 {
  if (value < min) {
    min
  }
  else if (value > max) {
    max
  }
  else {
    value
  }
}

mod: fn (dividend: f64, divisor: f64) f64 {
  dividend - (floor(dividend / divisor) * divisor)
}

modf: fn (dividend: f32, divisor: f32) f32 {
  dividend - (floor(dividend / divisor) * divisor)
}

main: fn () void {
  // uncomment this log to verify we ran
  // logi(42)
}
`

  if (debug) {
    console.groupCollapsed('code')
    console.log(text)
    console.groupEnd()
  }

  try {
    const tokens = lexify(text)
    const ast = compilerParse(tokens)
    const wasm = generateModule(ast)
    const binary = wasm.toByteArray()
    return { text, binary }
  }
  catch (error) {
    return { text, error: error as Error }
  }
}
